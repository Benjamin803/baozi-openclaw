#!/usr/bin/env bun
// Export — Generate HTML dashboard or JSON export
//
// Usage:
//   bun run export                  — Generate HTML dashboard
//   bun run export -- --json        — Export raw JSON
//   bun run export -- --markdown    — Export as Markdown report

import { fetchProofs, calculateStats, solscanUrl, tierDescription } from "../api/proofs.ts";
import { generateHTML } from "../dashboard/renderer.ts";
import { writeFileSync } from "fs";

function parseArgs(): { format: "html" | "json" | "markdown"; output?: string } {
  const args = process.argv.slice(2);
  let format: "html" | "json" | "markdown" = "html";
  let output: string | undefined;

  for (let i = 0; i < args.length; i++) {
    switch (args[i]) {
      case "--json":
        format = "json";
        break;
      case "--markdown":
      case "--md":
        format = "markdown";
        break;
      case "--output":
      case "-o":
        output = args[++i];
        break;
    }
  }

  return { format, output };
}

function generateMarkdown(proofs: Awaited<ReturnType<typeof fetchProofs>>, stats: ReturnType<typeof calculateStats>): string {
  const lines = [
    "# Trust Proof Explorer — Baozi Markets",
    "",
    `> Every resolution has receipts. ${stats.totalMarkets} markets resolved with full evidence trails.`,
    "",
    "## Oracle Stats",
    "",
    `| Metric | Value |`,
    `|--------|-------|`,
    `| Total Markets Resolved | ${stats.totalMarkets} |`,
    `| Proof Batches | ${stats.totalBatches} |`,
    `| Disputes Filed | 0 |`,
    `| Resolutions Overturned | 0 |`,
    `| Trust Score | 100% |`,
    `| Date Range | ${stats.dateRange.earliest} to ${stats.dateRange.latest} |`,
    "",
    "## Resolution Proofs",
    "",
  ];

  for (const batch of proofs) {
    const tier = tierDescription(batch.tier);
    lines.push(`### ${batch.title}`);
    lines.push(`**Date:** ${batch.date} | **Layer:** ${batch.layer} | **Category:** ${batch.category} | **Tier ${batch.tier}:** ${tier.name}`);
    lines.push("");

    for (const market of batch.markets) {
      lines.push(`#### ${market.question}`);
      lines.push(`- **Outcome:** ${market.outcome}`);
      lines.push(`- **Evidence:** ${market.evidence}`);
      lines.push(`- **Source:** [${market.source}](${market.source})`);
      lines.push(`- **PDA:** \`${market.pda}\``);
      lines.push(`- **Solscan:** [View on Solscan](${solscanUrl(market.pda)})`);
      lines.push("");
    }
  }

  lines.push("## Trust Comparison", "");
  lines.push("| Feature | Baozi | Polymarket | Kalshi |");
  lines.push("|---------|-------|------------|--------|");
  lines.push("| Evidence stored | IPFS + On-chain | None | None |");
  lines.push("| Proof public | YES | NO | NO |");
  lines.push("| Resolution method | Grandma Mei + Pyth | UMA Oracle | Internal |");
  lines.push("| Multisig | Squads (2-of-2) | UMA vote | Centralized |");
  lines.push("| Evidence trail | FULL | NONE | NONE |");
  lines.push("| Oracle tiers | 3 | 1 | 1 |");
  lines.push("| Transparency | FULL | PARTIAL | MINIMAL |");
  lines.push("");
  lines.push("---");
  lines.push(`*Generated by Trust Proof Explorer v1.0.0 — ${new Date().toISOString().slice(0, 16)}*`);

  return lines.join("\n");
}

async function main() {
  const { format, output } = parseArgs();

  console.log("Fetching proofs from Baozi API...");
  const proofs = await fetchProofs();
  const stats = calculateStats(proofs);

  let content: string;
  let ext: string;

  switch (format) {
    case "html":
      content = generateHTML(proofs, stats);
      ext = "html";
      break;
    case "json":
      content = JSON.stringify({ proofs, stats, generatedAt: new Date().toISOString() }, null, 2);
      ext = "json";
      break;
    case "markdown":
      content = generateMarkdown(proofs, stats);
      ext = "md";
      break;
  }

  const filename = output || `trust-proof-explorer.${ext}`;
  writeFileSync(filename, content);
  console.log(`Exported ${format.toUpperCase()} to ${filename}`);
  console.log(`  Proofs: ${stats.totalBatches} batches, ${stats.totalMarkets} markets`);
}

main().catch((err) => {
  console.error("Error:", err.message);
  process.exit(1);
});
